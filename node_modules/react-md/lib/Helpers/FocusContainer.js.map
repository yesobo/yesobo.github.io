{"version":3,"sources":["../../src/js/Helpers/FocusContainer.js"],"names":["hrefables","map","tag","join","disableables","FOCUSABLE_QUERY","FocusContainer","_enableFocusTrap","window","addEventListener","_handleKeyDown","_disableFocusTrap","removeEventListener","_attemptInitialFocus","_container","initialFocus","props","toFocus","document","getElementById","querySelector","_focusables","debugError","process","env","NODE_ENV","Error","focus","_containFocus","containerRef","focusOnMount","containFocus","Array","prototype","slice","call","querySelectorAll","filter","el","tabIndex","e","_shifted","shiftKey","additionalFocusKeys","length","preventDefault","target","first","focusables","last","nextProps","Component","component","propTypes","oneOfType","string","func","isRequired","style","object","className","children","node","bool","arrayOf","number","defaultProps"],"mappings":"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","file":"FocusContainer.js","sourcesContent":["import React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport { findDOMNode } from 'react-dom';\n\nimport isValidFocusKeypress from '../utils/EventUtils/isValidFocusKeypress';\n\nconst hrefables = ['a', 'area'].map(tag => `${tag}[href],`).join('');\nconst disableables = ['button', 'input', 'textarea', 'select'].map(tag => `${tag}:not([disabled]),`).join('');\nconst FOCUSABLE_QUERY = `${hrefables}${disableables}*[tabIndex]`;\n\n/**\n * This component is used for keeping the focus within some container. When the container\n * is mounted and the `focusOnMount` prop is `true`, it will attempt to focus either:\n * - an element that matches `document.getElementById(this.props.initialFocus)`\n * - an element that matches `this._container.querySelector(this.props.initialFocus)`\n * - the first focusable element in it's children (if `this.props.initialFocus` is omitted)\n */\nexport default class FocusContainer extends PureComponent {\n  static propTypes = {\n    /**\n     * The component to render as. This can be a React DOM element or\n     * a react Component.\n     */\n    component: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.func,\n    ]).isRequired,\n\n    /**\n     * An optional style to apply.\n     */\n    style: PropTypes.object,\n\n    /**\n     * An optional className to apply.\n     */\n    className: PropTypes.string,\n\n    /**\n     * The children to display.\n     */\n    children: PropTypes.node,\n\n    /**\n     * An optional id string or a query selector string to use for the initial focus.\n     * This will only be triggered if the `focusOnMount` prop is `true`. If this is\n     * omitted and the `focusOnMount` prop is `true`, the first focusable element in the\n     * container will be focused.\n     *\n     * Examples:\n     *\n     * ```js\n     * initialFocus=\"#someAmazingId\"\n     * // or\n     * initialFocus=\".md-btn,.md-list-tile\"\n     * ```\n     */\n    initialFocus: PropTypes.string,\n\n    /**\n     * Boolean if an element in the container should be focused when mounted.\n     */\n    focusOnMount: PropTypes.bool,\n\n    /**\n     * An optional list of additional key codes to use for focus events.\n     */\n    additionalFocusKeys: PropTypes.arrayOf(PropTypes.number),\n\n    /**\n     * Boolean if the focus container should start or stop containing the focus within the container.\n     * This is useful for changing the focus requirements after mount.\n     */\n    containFocus: PropTypes.bool,\n  };\n\n  static defaultProps = {\n    component: 'div',\n    containFocus: true,\n  };\n\n  componentWillReceiveProps(nextProps) {\n    if (this.props.containFocus === nextProps.containFocus) {\n      return;\n    }\n\n    if (nextProps.containFocus) {\n      this._enableFocusTrap();\n      this._attemptInitialFocus();\n    } else {\n      this._disableFocusTrap();\n    }\n  }\n\n  componentDidUpdate() {\n    if (this.props.containFocus && this._container) {\n      this._focusables = Array.prototype.slice.call(this._container.querySelectorAll(FOCUSABLE_QUERY))\n        .filter(el => el.tabIndex !== -1);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.props.containFocus) {\n      this._disableFocusTrap();\n    }\n  }\n\n  _enableFocusTrap = () => {\n    window.addEventListener('keydown', this._handleKeyDown, true);\n  };\n\n  _disableFocusTrap = () => {\n    window.removeEventListener('keydown', this._handleKeyDown, true);\n  };\n\n  _attemptInitialFocus = () => {\n    if (!this._container) {\n      return;\n    }\n\n    const { initialFocus } = this.props;\n\n    const toFocus = initialFocus\n      ? document.getElementById(initialFocus) || this._container.querySelector(initialFocus)\n      : this._focusables[0];\n\n    let debugError;\n    if (!toFocus && initialFocus) {\n      debugError = ' The `initialFocus` did not match a document\\'s `id` or was an invalid ';\n      debugError += `\\`querySelector\\` for the container. \\`initialFocus\\`: \\`${initialFocus}\\`. `;\n      debugError += 'If this was supposed to be an `id`, make sure to prefix with the `#` symbol.';\n    }\n\n    if (process.env.NODE_ENV !== 'production' && !toFocus) {\n      throw new Error(\n        'You specified that the `FocusContainer` should focus an element on mount, ' +\n        'but a focusable element was not found in the children. This could be because ' +\n        'the `initialFocus` prop is an invalid id or query selector, or the children ' +\n        `do not contain a valid focusable element.${debugError}`\n      );\n    }\n\n    if (toFocus) {\n      toFocus.focus();\n    }\n  };\n\n  /**\n   * Manages the event listeners to contain the focus within some container.  When the container\n   * ref is not null, the container has mounted and then attempts to focus an element inside\n   * if the `focusOnMount` prop is `true`.\n   */\n  _containFocus = (containerRef) => {\n    if (containerRef === null) {\n      this._container = null;\n      this._disableFocusTrap();\n      return;\n    }\n\n    const { focusOnMount, containFocus } = this.props;\n    this._container = findDOMNode(containerRef);\n    this._focusables = Array.prototype.slice.call(this._container.querySelectorAll(FOCUSABLE_QUERY))\n      .filter(el => el.tabIndex !== -1);\n\n    if (focusOnMount) {\n      this._attemptInitialFocus();\n    }\n\n    if (containFocus) {\n      this._enableFocusTrap();\n    }\n  };\n\n  _handleKeyDown = (e) => {\n    this._shifted = e.shiftKey;\n    if (!isValidFocusKeypress(e, this.props.additionalFocusKeys)) {\n      return;\n    } else if (this._focusables.length === 1) {\n      e.preventDefault();\n      return;\n    }\n\n    const { target, shiftKey } = e;\n    const [first, ...focusables] = this._focusables;\n    const last = focusables[focusables.length - 1];\n\n    if (shiftKey && target === first) {\n      e.preventDefault();\n      last.focus();\n    } else if (!shiftKey && target === last) {\n      e.preventDefault();\n      first.focus();\n    }\n  };\n\n  render() {\n    const {\n      component: Component,\n      /* eslint-disable no-unused-vars */\n      initialFocus,\n      focusOnMount,\n      containFocus,\n      additionalFocusKeys,\n      /* eslint-enable no-unused-vars */\n      ...props\n    } = this.props;\n\n    return <Component {...props} ref={this._containFocus} />;\n  }\n}\n"]}