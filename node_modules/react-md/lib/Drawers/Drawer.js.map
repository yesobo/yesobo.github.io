{"version":3,"sources":["../../src/js/Drawers/Drawer.js"],"names":["oneOfDrawerTypes","oneOf","FULL_HEIGHT","CLIPPED","FLOATING","PERSISTENT","PERSISTENT_MINI","TEMPORARY","TEMPORARY_MINI","Drawer","props","defaultProps","mobileMinWidth","tabletMinWidth","desktopMinWidth","mobileType","tabletType","desktopType","constantType","window","type","mobile","tablet","desktop","matchesMedia","min","max","media","matchMedia","matches","defaultVisible","defaultMedia","overlay","state","animating","overlayActive","drawerActive","_initialFix","visible","_updateType","addEventListener","_updateMedia","nextProps","transitionDuration","_animate","_timeout","clearTimeout","_closeTimeout","removeEventListener","id","style","className","navStyle","navClassName","component","navItems","header","children","inline","position","clickableDesktopOverlay","lastChild","portal","overlayStyle","overlayClassName","propType","propVisible","propRenderNode","renderNode","propNavItemsId","navItemsId","propZDepth","zDepth","onMediaTypeChange","onVisibilityChange","autoclose","autocloseAfterInk","onVisibilityToggle","closeOnNavItemClick","context","mini","temporary","floating","permanent","Component","navigation","_setNavigation","_handleNavClick","map","overlayVisible","drawer","_closeDrawer","DrawerTypes","propTypes","oneOfType","number","string","object","func","element","arrayOf","shape","divider","bool","subheader","primaryText","node","isRequired","propName","others","err","Error","contextTypes","getCurrentMedia","diffType","diffMedia","prevVisible","realState","setState","timeout","setTimeout","_navigation","e","enabled","target","contains","classList","getAttribute","parentNode","callback"],"mappings":"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","file":"Drawer.js","sourcesContent":["import React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport { findDOMNode } from 'react-dom';\nimport cn from 'classnames';\nimport deprecated from 'react-prop-types/lib/deprecated';\n\nimport { MOBILE_MIN_WIDTH, TABLET_MIN_WIDTH, DESKTOP_MIN_WIDTH } from '../constants/media';\nimport TICK from '../constants/CSSTransitionGroupTick';\nimport getField from '../utils/getField';\nimport mapToListParts from '../utils/mapToListParts';\nimport controlled from '../utils/PropTypes/controlled';\nimport Paper from '../Papers/Paper';\nimport Portal from '../Helpers/Portal';\nimport List from '../Lists/List';\nimport Overlay from './Overlay';\n\nimport { isTemporary, isPermanent, isMini } from './isType';\nimport DrawerTypes from './DrawerTypes';\n\nconst oneOfDrawerTypes = PropTypes.oneOf([\n  DrawerTypes.FULL_HEIGHT,\n  DrawerTypes.CLIPPED,\n  DrawerTypes.FLOATING,\n  DrawerTypes.PERSISTENT,\n  DrawerTypes.PERSISTENT_MINI,\n  DrawerTypes.TEMPORARY,\n  DrawerTypes.TEMPORARY_MINI,\n]);\n\n/**\n * The `Drawer` component is used for having a sliding panel of content or navigation\n * that appears from the side of a screen.\n *\n * If the `Drawer` uses any of the `_MINI` drawer types, you will need to also create another\n * `Drawer` that is not `_MINI`. Transitioning the `width` on mobile devices is very sluggish,\n * and it isn't much more work to create another drawer.\n */\nexport default class Drawer extends PureComponent {\n  static DrawerTypes = DrawerTypes;\n  static propTypes = {\n    /**\n     * An optional id to provide to the drawer. This is generally a good idea to provide if\n     * there are any `navItems` defined.\n     *\n     * @see {@link #navItemsId}\n     */\n    id: PropTypes.oneOfType([\n      PropTypes.number,\n      PropTypes.string,\n    ]),\n\n    /**\n     * An optional id to provide to the navItems list. If this is omitted and the `id` prop is\n     * defined, it will be defaulted to `${id}-nav-items`.\n     */\n    navItemsId: PropTypes.oneOfType([\n      PropTypes.number,\n      PropTypes.string,\n    ]),\n\n    /**\n     * An optional style to apply.\n     */\n    style: PropTypes.object,\n\n    /**\n     * An optional className to apply.\n     */\n    className: PropTypes.string,\n\n    /**\n     * An optional style to apply to the `List` surrounding the `navItems`.\n     */\n    navStyle: PropTypes.object,\n\n    /**\n     * An optional className to apply to the `List` surrounding the `navItems`.\n     */\n    navClassName: PropTypes.string,\n\n    /**\n     * An optional style to apply to the overlay.\n     */\n    overlayStyle: PropTypes.object,\n\n    /**\n     * An optional className to apply to the overlay.\n     */\n    overlayClassName: PropTypes.string,\n\n    /**\n     * An optional component to render the drawer in. When this prop is undefined, the drawer\n     * will be rendered as a `nav` if the `navItems` prop is defined, otherwise an `aside`.\n     */\n    component: PropTypes.oneOfType([\n      PropTypes.func,\n      PropTypes.element,\n    ]),\n\n    /**\n     * An optional list of navigation items to display in the drawer. This list can either contain\n     * a valid child component for a `List` or an object used to create a `Divider`, `Subheader`,\n     * or `ListItem`.\n     *\n     * - To create a divider in the list, set a `divider` key to `true`. Any other keys will be\n     * passed to the `Divider` component.\n     * - To create a subheader in the list, set the `subheader` key to `true`. Any other keys will\n     * be passed to the `Subheader` component.\n     * - To create a list item, just create an object with any normal `ListItem` props.\n     */\n    navItems: PropTypes.arrayOf(PropTypes.oneOfType([\n      PropTypes.element,\n      PropTypes.shape({\n        divider: PropTypes.bool,\n        subheader: PropTypes.bool,\n        primaryText: PropTypes.node,\n      }),\n    ])),\n\n    /**\n     * Boolean if a temporary drawer should close when a nav item is clicked.\n     */\n    autoclose: PropTypes.bool,\n\n    /**\n     * An optional header to display. This _should_ normally be a toolbar.\n     */\n    header: PropTypes.node,\n\n    /**\n     * Any additional children to display after the `header` and `navItems`.\n     */\n    children: PropTypes.node,\n\n    /**\n     * The drawer type to use when the current device matches the mobile\n     * media query.\n     */\n    mobileType: PropTypes.oneOf([\n      Drawer.DrawerTypes.TEMPORARY,\n      Drawer.DrawerTypes.TEMPORARY_MINI,\n    ]).isRequired,\n\n    /**\n     * The min-width to use for the mobile media query.\n     */\n    mobileMinWidth: PropTypes.number.isRequired,\n\n    /**\n     * The drawer type to use when the current device matches the tablet\n     * media query.\n     */\n    tabletType: oneOfDrawerTypes.isRequired,\n\n    /**\n     * The min-width to use for the tablet media query.\n     */\n    tabletMinWidth: PropTypes.number.isRequired,\n\n    /**\n     * The drawer type to use when the current device matches the desktop media\n     * query.\n     */\n    desktopType: oneOfDrawerTypes.isRequired,\n\n    /**\n     * The min-width for a desktop screen.\n     */\n    desktopMinWidth: PropTypes.number.isRequired,\n\n    /**\n     * An optional type to enforce across all media sizes. Since `mobile` devices are\n     * included, you are required to manually specify when the `type` should be `temporary`.\n     *\n     * When the `type` is not one of the `temporary` types, the `onMediaTypeChange` prop\n     * must be provided.\n     */\n    type: (props, propName, component, ...others) => {\n      const type = props[propName];\n      if (isTemporary(type)) {\n        return oneOfDrawerTypes(props, propName, component, ...others);\n      }\n\n      let err = oneOfDrawerTypes(props, propName, component, ...others);\n      if (!err && typeof type !== 'undefined' && !isMini(type) && typeof props.onMediaTypeChange === 'undefined') {\n        err = new Error(\n          `You provided a \\`${propName}\\` prop to the ${component} without the \\`onMediaTypeChange\\` ` +\n          `handler. The \\`onMediaTypeChange\\` prop must be specified when the \\`${propName}\\` is not ` +\n          'one of the `temporary` types.'\n        );\n      }\n\n      return err;\n    },\n\n    /**\n     * An optional function to call when the drawer's type changes when the screen resizes.\n     * The callback will include the new `type` that should be used for the screen size,\n     * and an object containing the media matches for `mobile`, `tablet`, and `desktop`.\n     *\n     * ```js\n     * this.props.onMediaTypeChange(Drawer.DrawerTypes.TEMPORARY, {\n     *   mobile: true,\n     *   tablet: false,\n     *   desktop: false,\n     * });\n     * ```\n     */\n    onMediaTypeChange: PropTypes.func,\n\n    /**\n     * The default drawer type to display on initial render. The drawer will automatically\n     * adjust itself to the correct media once it has mounted. This prop is really only useful\n     * for server side rendering.\n     */\n    defaultMedia: PropTypes.oneOf(['mobile', 'tablet', 'desktop']).isRequired,\n\n    /**\n     * Boolean if there should be a visible overlay when the drawer is visible. The default behavior\n     * is to only include a visible overlay when the `type` is `TEMPORARY` or `TEMPORARY_MINI` and\n     * the device is not a desktop.\n     *\n     * Definining this variable as `true` or `false` will override any default behavior. This means that\n     * if this is enabled for a full-height drawer, an overlay will still be created.\n     */\n    overlay: PropTypes.bool,\n\n    /**\n     * Boolean if the Portal's functionality of rendering in a separate react tree should be applied\n     * to the drawer. The overlay that appears for temporary type drawers will still appear in the\n     * separate subtree.\n     *\n     * @see {@link Helpers/Portal}\n     */\n    portal: PropTypes.bool,\n\n    /**\n     * An optional DOM Node to render the drawer into. The default is to render as\n     * the first child in the `body`.\n     *\n     * > This prop will not be used when the drawer is of the permanent type or `inline` is specified\n     * since the `Portal` component will not be used.\n     */\n    renderNode: PropTypes.object,\n\n    /**\n     * Boolean if the drawer should be rendered as the last child instead of the first child\n     * in the `renderNode` or `body`.\n     *\n     * > This prop will not be used when the drawer is of the permanent type or `inline` is specified\n     * since the `Portal` component will not be used.\n     */\n    lastChild: PropTypes.bool,\n\n    /**\n     * Boolean if the drawer is visible by default. If this is omitted, the drawer will be visible\n     * if the current drawer type is NOT `Drawer.DrawerTypes.TEMPORARY` or `Drawer.DrawerTypes.TEMPORARY_MINI`.\n     *\n     * This basically means that if you are using the default configuration, a mobile device's drawer\n     * will be hidden while tablets and desktops will be visible.\n     */\n    defaultVisible: PropTypes.bool,\n\n    /**\n     * Boolean if the drawer is visible. This will force the component to define the `onVisibilityChange`\n     * prop as well as manually updating the drawer's visibility.\n     */\n    visible: controlled(PropTypes.bool, 'onVisibilityChange', 'defaultVisible'),\n\n    /**\n     * An optional function to call when the visibility of the drawer is changed. The function will\n     * be called with the new visibility state.\n     *\n     * ```js\n     * onVisibilityChange(!currentlyVisible);\n     * ```\n     */\n    onVisibilityChange: PropTypes.func,\n\n    /**\n     * The drawer's position on the page when it is not `inline`. When the drawer's position is `left`,\n     * the width will be `calc(100vw - 56px)` on mobile devices and `$md-drawer-desktop-width` on desktops.\n     *\n     * When the position is `right`, the width will be `100vw` for mobile devices and scaling to the drawer's\n     * children width on desktops.\n     */\n    position: PropTypes.oneOf(['left', 'right']).isRequired,\n\n    /**\n     * Boolean if the drawer should be displayed inline instead of fixed to the page. When this prop\n     * is enabled, the `position` prop will not be used.\n     */\n    inline: PropTypes.bool,\n\n    /**\n     * The `$md-drawer-transition-time` value from sass.\n     */\n    transitionDuration: PropTypes.number.isRequired,\n\n    /**\n     * Boolean if the temporary drawer's overlay should be created on desktop screens. This is really used so that\n     * the drawer will close when a user clicks anywhere on the page except in the drawer.\n     */\n    clickableDesktopOverlay: PropTypes.bool,\n\n    /**\n     * Boolean if the `autoclose` feature should wait for the ink transition to finish before automatically\n     * closing the drawer. This will add a `300ms` delay. If this is `false`, there will only be a `17ms` delay.\n     *\n     * > The delay is required so that any event listeners will still be correctly invoked when an item is clicked.\n     */\n    autocloseAfterInk: PropTypes.bool,\n\n    /**\n     * Boolean if the `type` prop should be constant across all media sizes. This is only valid if the `type` is\n     * one of the temporary types.\n     *\n     * This will basically mean that when attempting to do a media adjustment, it will use the `type` prop instead of\n     * `mobileType`, `tabletType`, and `desktopType` to determine the next drawer type.\n     */\n    constantType: PropTypes.bool.isRequired,\n\n    /**\n     * An optional zDepth to apply to the drawer. If this is omitted, the value will be set as follows:\n     * - floating || inline = 1\n     * - temporary = 5\n     * - all others = 1\n     *\n     * @see {@link Papers/Paper#zDepth}\n     */\n    zDepth: PropTypes.number,\n\n    closeOnNavItemClick: deprecated(PropTypes.bool, 'Use `autoclose` instead'),\n    onVisibilityToggle: deprecated(PropTypes.func, 'Use `onVisibilityChange` instead'),\n  };\n\n  static defaultProps = {\n    defaultMedia: 'mobile',\n    mobileType: Drawer.DrawerTypes.TEMPORARY,\n    mobileMinWidth: MOBILE_MIN_WIDTH,\n    tabletType: Drawer.DrawerTypes.PERSISTENT,\n    tabletMinWidth: TABLET_MIN_WIDTH,\n    desktopType: Drawer.DrawerTypes.FULL_HEIGHT,\n    desktopMinWidth: DESKTOP_MIN_WIDTH,\n    position: 'left',\n    transitionDuration: 300,\n    autoclose: true,\n    clickableDesktopOverlay: true,\n    constantType: true,\n  };\n\n  /**\n   * Determines the current media and returns an object containing matches for `mobile`, `tablet`, `desktop`,\n   * and the current drawer type. This expects a `props` object of the drawer.\n   *\n   * If this is used server side, it will default to only matching mobile.\n   *\n   * @param {Object=} props - The current drawer's prop shape to extract the mobile, tablet,\n   *    and desktop type/min widths. This defaults to the drawer's default props.\n   * @return {Object} an object containing the media matches and the current type to use for the drawer.\n   */\n  static getCurrentMedia(props = Drawer.defaultProps) {\n    const {\n      mobileMinWidth,\n      tabletMinWidth,\n      desktopMinWidth,\n      mobileType,\n      tabletType,\n      desktopType,\n      constantType,\n    } = props;\n    if (typeof window === 'undefined') {\n      const type = constantType && props.type ? props.type : mobileType;\n      return { mobile: true, tablet: false, desktop: false, type };\n    }\n\n    const mobile = Drawer.matchesMedia(mobileMinWidth, tabletMinWidth - 1);\n    const tablet = Drawer.matchesMedia(tabletMinWidth, desktopMinWidth);\n    const desktop = Drawer.matchesMedia(desktopMinWidth);\n\n    let type;\n    if (constantType && props.type && isTemporary(props.type)) {\n      type = props.type;\n    } else if (desktop) {\n      type = desktopType;\n    } else if (tablet) {\n      type = tabletType;\n    } else {\n      type = mobileType;\n    }\n\n    return { type, mobile, tablet, desktop };\n  }\n\n  /**\n   * Simply does a `window.matchMedia(query)` where the query gets defined as a min width\n   * and optional max width.\n   *\n   * @param {number} min - The min width for the media query.\n   * @param {number=} max - An optional max width to include for the media query.\n   * @return {boolean} true if the media matches.\n   */\n  static matchesMedia(min, max) {\n    let media = `screen and (min-width: ${min}px)`;\n    if (max) {\n      media += ` and (max-width: ${max}px)`;\n    }\n\n    return window.matchMedia(media).matches;\n  }\n\n  static contextTypes = {\n    renderNode: PropTypes.object,\n  };\n\n  constructor(props) {\n    super(props);\n\n    const { defaultVisible, defaultMedia, overlay } = props;\n\n    this.state = {\n      mobile: defaultMedia === 'mobile',\n      tablet: defaultMedia === 'tablet',\n      desktop: defaultMedia === 'desktop',\n      animating: false,\n      overlayActive: false,\n      drawerActive: false,\n    };\n\n    if (typeof props.type === 'undefined') {\n      this.state.type = props[`${defaultMedia}Type`];\n    }\n\n    const type = getField(props, this.state, 'type');\n    this._initialFix = true;\n\n    if (typeof props.visible === 'undefined') {\n      let visible = isPermanent(type) || isMini(type);\n      if (!visible && typeof defaultVisible !== 'undefined') {\n        visible = defaultVisible;\n      }\n\n      this.state.visible = visible;\n    }\n\n    const visible = getField(props, this.state, 'visible');\n\n    this.state.overlayActive = (typeof overlay !== 'undefined' ? overlay : isTemporary(type) && !this.state.desktop)\n      && visible;\n    this.state.drawerActive = visible;\n  }\n\n  componentWillMount() {\n    if (typeof window !== 'undefined') {\n      this._updateType(this.props);\n    }\n  }\n\n  componentDidMount() {\n    if (!isMini(getField(this.props, this.state, 'type'))) {\n      window.addEventListener('resize', this._updateMedia);\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    const {\n      mobileMinWidth,\n      mobileType,\n      tabletMinWidth,\n      tabletType,\n      desktopMinWidth,\n      desktopType,\n    } = this.props;\n\n    if (nextProps.mobileMinWidth !== mobileMinWidth || nextProps.mobileType !== mobileType\n      || nextProps.tabletMinWidth !== tabletMinWidth || nextProps.tabletType !== tabletType\n      || nextProps.desktopMinWidth !== desktopMinWidth || nextProps.desktopType !== desktopType) {\n      this._updateType(nextProps);\n    }\n\n    const { visible, transitionDuration, overlay } = nextProps;\n    if (this.props.visible === nextProps.visible) {\n      return;\n    }\n\n    const type = getField(nextProps, this.state, 'type');\n    this._animate(visible, type, transitionDuration, overlay, this.state.desktop);\n  }\n\n  componentWillUnmount() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n    }\n\n    if (this._closeTimeout) {\n      clearTimeout(this._closeTimeout);\n    }\n\n    window.removeEventListener('resize', this._updateMedia);\n  }\n\n  _updateType = (props) => {\n    const {\n      onMediaTypeChange,\n      overlay,\n      transitionDuration,\n    } = props;\n\n    const onVisibilityChange = props.onVisibilityToggle || props.onVisibilityChange;\n\n    let state = Drawer.getCurrentMedia(props);\n    const diffType = getField(props, this.state, 'type') !== state.type;\n    const diffMedia = state.mobile !== this.state.mobile\n      || state.tablet !== this.state.tablet\n      || state.desktop !== this.state.desktop;\n\n    if (onMediaTypeChange && (diffType || diffMedia)) {\n      onMediaTypeChange(state.type, { mobile: state.mobile, tablet: state.tablet, desktop: state.desktop });\n    }\n\n    if (diffType) {\n      let visible = isPermanent(state.type);\n      if (this._initialFix) {\n        if (props.defaultVisible) {\n          visible = props.defaultVisible;\n        } else if (props.visible) {\n          visible = props.visible;\n        }\n      }\n\n      const prevVisible = getField(props, this.state, 'visible');\n      if (onVisibilityChange && (visible !== prevVisible)) {\n        onVisibilityChange(visible);\n      }\n\n      if (typeof props.visible === 'undefined') {\n        state.visible = visible;\n        this._animate(visible, state.type, transitionDuration, overlay, state.desktop);\n      }\n    } else if (this._initialFix && diffMedia) {\n      state.overlayActive = (typeof overlay !== 'undefined' ? overlay : isTemporary(state.type) && !state.desktop)\n        && getField(props, this.state, 'visible');\n    }\n\n    if (typeof props.type !== 'undefined') {\n      const { type, ...realState } = state; // eslint-disable-line no-unused-vars\n      state = realState;\n    }\n\n    this._initialFix = false;\n    this.setState(state);\n  };\n\n  _updateMedia = () => {\n    this._updateType(this.props);\n  };\n\n  _animate = (visible, type, timeout, overlay, desktop) => {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n    }\n\n    if (visible) {\n      this._timeout = setTimeout(() => {\n        this._timeout = null;\n\n        this.setState({\n          overlayActive: overlay || (isTemporary(type) && !desktop),\n          drawerActive: true,\n          animating: true,\n        });\n      }, TICK);\n    } else {\n      this._timeout = setTimeout(() => {\n        this._timeout = null;\n\n        this.setState({ animating: false });\n      }, timeout);\n      this.setState({ animating: true, overlayActive: false, drawerActive: false });\n    }\n  };\n\n  _setNavigation = (navigation) => {\n    this._navigation = findDOMNode(navigation);\n  };\n\n  _handleNavClick = (e) => {\n    const { closeOnNavItemClick, autoclose, autocloseAfterInk } = this.props;\n    const enabled = typeof closeOnNavItemClick !== 'undefined' ? closeOnNavItemClick : autoclose;\n    if (!enabled || !isTemporary(getField(this.props, this.state, 'type'))) {\n      return;\n    }\n\n    let { target } = e;\n    while (target && this._navigation.contains(target)) {\n      if (target.classList.contains('md-list-tile')) {\n        // Clicked a nav item that has a nested list\n        if (target.getAttribute('aria-expanded') !== null) {\n          return;\n        }\n\n        this._closeTimeout = setTimeout(() => {\n          this._closeTimeout = null;\n\n          this._closeDrawer(e);\n        }, autocloseAfterInk ? 300 : TICK);\n        return;\n      }\n\n      target = target.parentNode;\n    }\n  };\n\n  _closeDrawer = () => {\n    const { onVisibilityChange, onVisibilityToggle, transitionDuration, overlay } = this.props;\n    const callback = onVisibilityToggle || onVisibilityChange;\n    if (callback) {\n      callback(false);\n    }\n\n    if (typeof this.props.visible === 'undefined') {\n      this.setState({ visible: false });\n      this._animate(false, getField(this.props, this.state, 'type'), transitionDuration, overlay, this.state.desktop);\n    }\n  };\n\n  render() {\n    const { overlayActive, drawerActive, animating } = this.state;\n    const {\n      id,\n      style,\n      className,\n      navStyle,\n      navClassName,\n      component,\n      navItems,\n      header,\n      children,\n      inline,\n      position,\n      overlay,\n      clickableDesktopOverlay,\n      lastChild,\n      portal,\n      overlayStyle,\n      overlayClassName,\n      /* eslint-disable no-unused-vars */\n      type: propType,\n      visible: propVisible,\n      renderNode: propRenderNode,\n      navItemsId: propNavItemsId,\n      zDepth: propZDepth,\n      constantType,\n      defaultVisible,\n      defaultMedia,\n      mobileType,\n      mobileMinWidth,\n      tabletType,\n      tabletMinWidth,\n      desktopType,\n      desktopMinWidth,\n      transitionDuration,\n      onMediaTypeChange,\n      onVisibilityChange,\n      autoclose,\n      autocloseAfterInk,\n      // deprecated\n      onVisibilityToggle,\n      closeOnNavItemClick,\n      /* eslint-enable no-unused-vars */\n      ...props\n    } = this.props;\n\n    let { navItemsId, zDepth } = this.props;\n    if (!navItemsId && id) {\n      navItemsId = `${id}-nav-items`;\n    }\n\n    const { desktop } = this.state;\n    const renderNode = getField(this.props, this.context, 'renderNode');\n    const type = getField(this.props, this.state, 'type');\n    const visible = getField(this.props, this.state, 'visible');\n    const mini = isMini(type);\n    const temporary = isTemporary(type);\n    const floating = DrawerTypes.FLOATING === type;\n    const permanent = isPermanent(type);\n\n    let Component;\n    if (component) {\n      Component = component;\n    } else if (navItems) {\n      Component = 'nav';\n    } else {\n      Component = 'aside';\n    }\n\n    let navigation;\n    if (navItems) {\n      navigation = (\n        <List\n          ref={this._setNavigation}\n          key=\"navigation\"\n          id={navItemsId}\n          style={navStyle}\n          className={cn('md-list--drawer', {\n            'md-toolbar-relative': mini && !visible,\n            'md-background': floating,\n          }, navClassName)}\n          onClick={this._handleNavClick}\n        >\n          {navItems.map(mapToListParts)}\n        </List>\n      );\n    }\n\n    if (typeof zDepth === 'undefined') {\n      zDepth = 1;\n      if (floating || inline) {\n        zDepth = 0;\n      } else if (!mini && temporary) {\n        zDepth = 5;\n      }\n    }\n\n    let overlayVisible = overlay;\n    if (typeof overlayVisible !== 'boolean') {\n      overlayVisible = temporary && !mini && (!desktop || clickableDesktopOverlay) && (animating || visible);\n    }\n\n    const drawer = (\n      <Paper\n        {...props}\n        id={id}\n        key=\"drawer\"\n        component={Component}\n        zDepth={zDepth}\n        raiseOnHover={false}\n        style={style}\n        className={cn('md-drawer', {\n          [`md-drawer--${position}`]: !inline,\n          'md-drawer--fixed': !inline,\n          'md-drawer--inline': inline,\n          'md-drawer--active': mini || drawerActive,\n          'md-drawer--mini': mini,\n          'md-transition--deceleration': !mini && !permanent && visible,\n          'md-transition--acceleration': !mini && !permanent && !visible,\n          'md-background': inline || floating,\n          'md-background--card': !floating && !inline,\n        }, className)}\n      >\n        {header}\n        {navigation}\n        {children}\n        <Overlay\n          style={overlayStyle}\n          className={overlayClassName}\n          active={overlayActive}\n          onClick={this._closeDrawer}\n          visible={overlayVisible}\n          renderNode={renderNode}\n        />\n      </Paper>\n    );\n\n    if (inline || permanent) {\n      return drawer;\n    } else if (!portal) {\n      return mini || animating || visible ? drawer : null;\n    }\n\n    return (\n      <Portal visible={animating || visible} renderNode={renderNode} lastChild={lastChild}>\n        {drawer}\n      </Portal>\n    );\n  }\n}\n"]}