{"version":3,"sources":["../../src/js/utils/closest.js"],"names":["closest","el","type","nodeType","toUpperCase","node","parentElement","nodeName"],"mappings":";;;;;kBAWwBA,O;AAXxB;;AAEA;;;;;;;;;AASe,SAASA,OAAT,CAAiBC,EAAjB,EAAqBC,IAArB,EAA2B;AACxC,MAAI,OAAOD,GAAGD,OAAV,KAAsB,UAA1B,EAAsC;AACpC,WAAOC,GAAGD,OAAH,CAAWE,IAAX,CAAP;AACD;;AAED,MAAMC,WAAWD,KAAKE,WAAL,EAAjB;AACA,MAAIC,OAAOJ,GAAGK,aAAd;AACA,SAAOD,QAAQA,KAAKC,aAApB,EAAmC;AACjC,QAAID,KAAKE,QAAL,KAAkBJ,QAAtB,EAAgC;AAC9B,aAAOE,IAAP;AACD;;AAEDA,WAAOA,KAAKC,aAAZ;AACD;;AAED,SAAO,IAAP;AACD","file":"closest.js","sourcesContent":["/** @module utils/closest */\n\n/**\n * A _very_ primitive polyfill for the Element.closest function. If this is a browser that doesn't\n * support it (IE, Edge, etc), it will just keep searching the parent elements until the nodeName\n * matches the provided type.\n *\n * @param {Element} el - the html element to find a closest node type for\n * @param {String} type - the html element type to find.\n * @return {Element} the found element or null.\n */\nexport default function closest(el, type) {\n  if (typeof el.closest === 'function') {\n    return el.closest(type);\n  }\n\n  const nodeType = type.toUpperCase();\n  let node = el.parentElement;\n  while (node && node.parentElement) {\n    if (node.nodeName === nodeType) {\n      return node;\n    }\n\n    node = node.parentElement;\n  }\n\n  return null;\n}\n"]}