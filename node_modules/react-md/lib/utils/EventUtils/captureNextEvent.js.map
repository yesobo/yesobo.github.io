{"version":3,"sources":["../../../src/js/utils/EventUtils/captureNextEvent.js"],"names":["captureNextEvent","type","target","callback","el","window","cb","capture","e","stopPropagation","removeEventListener","addEventListener"],"mappings":";;;;;kBAcwBA,gB;AAdxB;;AAEA;;;;;;;;;;;;AAYe,SAASA,gBAAT,CAA0BC,IAA1B,EAAgCC,MAAhC,EAAwCC,QAAxC,EAAkD;AAC/D,MAAMC,KAAK,OAAOF,MAAP,KAAkB,UAAlB,IAAgCA,MAAhC,GAAyCA,MAAzC,GAAkDG,MAA7D;AACA,MAAMC,KAAK,OAAOJ,MAAP,KAAkB,UAAlB,GAA+BA,MAA/B,GAAwCC,QAAnD;;AAEA,MAAMI,UAAU,SAAVA,OAAU,IAAK;AACnBC,MAAEC,eAAF;AACA,QAAIH,EAAJ,EAAQ;AACNA,SAAGE,CAAH;AACD;;AAEDJ,OAAGM,mBAAH,CAAuBT,IAAvB,EAA6BM,OAA7B,EAAsC,IAAtC;AACD,GAPD;;AASAH,KAAGO,gBAAH,CAAoBV,IAApB,EAA0BM,OAA1B,EAAmC,IAAnC;AACD","file":"captureNextEvent.js","sourcesContent":["/** @module utils/EventUtils/captureNextEvent */\n\n/**\n * This function will capture the next event and stop propagation during the\n * bubbling cycle of events. This is really only useful if you want to stop\n * the default behavior of chained events.\n *\n * @param {String} type - The event type to capture.\n * @param {Object|func=} target - Either the DOM node to target, a callback function\n *      to call once the event has been captured, or undefined. If this is undefined,\n *      the event will be captured on the window.\n * @param {func=} callback - An optional callback function to call once the event\n *      has been captured.\n */\nexport default function captureNextEvent(type, target, callback) {\n  const el = typeof target !== 'function' && target ? target : window;\n  const cb = typeof target === 'function' ? target : callback;\n\n  const capture = e => {\n    e.stopPropagation();\n    if (cb) {\n      cb(e);\n    }\n\n    el.removeEventListener(type, capture, true);\n  };\n\n  el.addEventListener(type, capture, true);\n}\n"]}